# 명예의 전당 (1)
# 문제 설명
# "명예의 전당"이라는 TV 프로그램에서는 매일 1명의 가수가 노래를 부르고, 시청자들의 문자 투표수로 가수에게 점수를 부여합니다. 매일 출연한 가수의 점수가 지금까지 출연 가수들의 점수 중 상위 k번째 이내이면 해당 가수의 점수를 명예의 전당이라는 목록에 올려 기념합니다. 즉 프로그램 시작 이후 초기에 k일까지는 모든 출연 가수의 점수가 명예의 전당에 오르게 됩니다. k일 다음부터는 출연 가수의 점수가 기존의 명예의 전당 목록의 k번째 순위의 가수 점수보다 더 높으면, 출연 가수의 점수가 명예의 전당에 오르게 되고 기존의 k번째 순위의 점수는 명예의 전당에서 내려오게 됩니다.

# 이 프로그램에서는 매일 "명예의 전당"의 최하위 점수를 발표합니다. 예를 들어, k = 3이고, 7일 동안 진행된 가수의 점수가 [10, 100, 20, 150, 1, 100, 200]이라면, 명예의 전당에서 발표된 점수는 아래의 그림과 같이 [10, 10, 10, 20, 20, 100, 100]입니다.

# 그림1.png

# 명예의 전당 목록의 점수의 개수 k, 1일부터 마지막 날까지 출연한 가수들의 점수인 score가 주어졌을 때, 매일 발표된 명예의 전당의 최하위 점수를 return하는 solution 함수를 완성해주세요.

# 제한사항
# 3 ≤ k ≤ 100
# 7 ≤ score의 길이 ≤ 1,000
# 0 ≤ score[i] ≤ 2,000
# 입출력 예
# k	score	result
# 3	[10, 100, 20, 150, 1, 100, 200]	[10, 10, 10, 20, 20, 100, 100]
# 4	[0, 300, 40, 300, 20, 70, 150, 50, 500, 1000]	[0, 0, 0, 0, 20, 40, 70, 70, 150, 300]
# 입출력 예 설명
# 입출력 예 #1

# 문제의 예시와 같습니다.
# 입출력 예 #2

# 아래와 같이, [0, 0, 0, 0, 20, 40, 70, 70, 150, 300]을 return합니다. 그림2.png

def solution(k, score):
    answer = []
    lst = []
    n = 0
    l = len(score)
    while(n<l):
        if n<k:
            lst.append(score[n])
            lst.sort(reverse = True)
            answer.append(lst[-1])
        else:
            if score[n] >= lst[k-1]:
                lst = lst[:k]+[score[n]]
                lst.sort(reverse = True)
                lst = lst[:k]
            answer.append(lst[-1])
        n+=1
        
    return answer


# 테스트 1 〉	통과 (0.01ms, 10.2MB)
# 테스트 2 〉	통과 (0.01ms, 10.2MB)
# 테스트 3 〉	통과 (0.01ms, 10.2MB)
# 테스트 4 〉	통과 (0.01ms, 10.2MB)
# 테스트 5 〉	통과 (0.01ms, 10.4MB)
# 테스트 6 〉	통과 (0.01ms, 10.3MB)
# 테스트 7 〉	통과 (0.02ms, 10.2MB)
# 테스트 8 〉	통과 (0.02ms, 10.2MB)
# 테스트 9 〉	통과 (0.02ms, 10.3MB)
# 테스트 10 〉	통과 (0.03ms, 10.2MB)
# 테스트 11 〉	통과 (0.03ms, 10.2MB)
# 테스트 12 〉	통과 (0.46ms, 10.2MB)
# 테스트 13 〉	통과 (0.52ms, 10.2MB)
# 테스트 14 〉	통과 (0.33ms, 10.3MB)
# 테스트 15 〉	통과 (0.67ms, 10.3MB)
# 테스트 16 〉	통과 (0.69ms, 10.3MB)
# 테스트 17 〉	통과 (0.78ms, 10.3MB)
# 테스트 18 〉	통과 (0.74ms, 10.4MB)
# 테스트 19 〉	통과 (0.19ms, 10.3MB)
# 테스트 20 〉	통과 (0.19ms, 10.2MB)
# 테스트 21 〉	통과 (0.22ms, 10.4MB)
# 테스트 22 〉	통과 (0.39ms, 10.3MB)
# 테스트 23 〉	통과 (0.21ms, 10.2MB)
# 테스트 24 〉	통과 (0.22ms, 10.3MB)
# 테스트 25 〉	통과 (0.23ms, 10.3MB)
# 테스트 26 〉	통과 (0.01ms, 10.2MB)


## 다른 사람 알고리즘. min 함수가 매번 사용되서 내 알고리즘보다 좀 더 걸린다.

def solution(k, score):

    q = []

    answer = []
    for s in score:

        q.append(s)
        if (len(q) > k):
            q.remove(min(q))
        answer.append(min(q))

    return answer

# 테스트 1 〉	통과 (0.01ms, 10.1MB)
# 테스트 2 〉	통과 (0.01ms, 10.3MB)
# 테스트 3 〉	통과 (0.01ms, 10.2MB)
# 테스트 4 〉	통과 (0.01ms, 10.1MB)
# 테스트 5 〉	통과 (0.02ms, 10.2MB)
# 테스트 6 〉	통과 (0.01ms, 10.1MB)
# 테스트 7 〉	통과 (0.02ms, 10.2MB)
# 테스트 8 〉	통과 (0.04ms, 10.2MB)
# 테스트 9 〉	통과 (0.02ms, 10.2MB)
# 테스트 10 〉	통과 (0.07ms, 10.3MB)
# 테스트 11 〉	통과 (0.04ms, 10.2MB)
# 테스트 12 〉	통과 (1.88ms, 10.2MB)
# 테스트 13 〉	통과 (2.02ms, 10.2MB)
# 테스트 14 〉	통과 (1.46ms, 10.3MB)
# 테스트 15 〉	통과 (3.93ms, 10.3MB)
# 테스트 16 〉	통과 (6.63ms, 10.3MB)
# 테스트 17 〉	통과 (6.28ms, 10.2MB)
# 테스트 18 〉	통과 (4.16ms, 10.4MB)
# 테스트 19 〉	통과 (0.56ms, 10.5MB)
# 테스트 20 〉	통과 (0.83ms, 10.3MB)
# 테스트 21 〉	통과 (0.73ms, 10.4MB)
# 테스트 22 〉	통과 (0.75ms, 10.5MB)
# 테스트 23 〉	통과 (0.77ms, 10.4MB)
# 테스트 24 〉	통과 (0.82ms, 10.3MB)
# 테스트 25 〉	통과 (0.87ms, 10.4MB)
# 테스트 26 〉	통과 (0.01ms, 10.4MB)


## 힙큐를 이용한 풀이, 삽입이 자주 일어날수록 시간이 오래걸린다. 접근이 상대적으로 잦은 경우에 시간효율적.
## 공간효율성은 다소 떨어진다. 트리 구조이기 때문에 예상보다 더 많은 공간이 필요하다.
import heapq

def solution(k, score):
    max_heap = []
    answer = []

    for sc in score:
        heapq.heappush(max_heap, (-sc, sc))
        answer.append(max(heapq.nsmallest(k, max_heap))[1])

    return answer

# 테스트 1 〉	통과 (0.04ms, 10.3MB)
# 테스트 2 〉	통과 (0.03ms, 10MB)
# 테스트 3 〉	통과 (0.03ms, 10.2MB)
# 테스트 4 〉	통과 (0.03ms, 10.2MB)
# 테스트 5 〉	통과 (0.09ms, 10.2MB)
# 테스트 6 〉	통과 (0.03ms, 10.1MB)
# 테스트 7 〉	통과 (0.11ms, 10.1MB)
# 테스트 8 〉	통과 (0.11ms, 10.2MB)
# 테스트 9 〉	통과 (0.09ms, 10.3MB)
# 테스트 10 〉	통과 (0.22ms, 10.1MB)
# 테스트 11 〉	통과 (0.31ms, 10.2MB)
# 테스트 12 〉	통과 (41.12ms, 10.2MB)
# 테스트 13 〉	통과 (41.37ms, 10.2MB)
# 테스트 14 〉	통과 (27.85ms, 10.4MB)
# 테스트 15 〉	통과 (91.06ms, 10.4MB)
# 테스트 16 〉	통과 (102.38ms, 10.3MB)
# 테스트 17 〉	통과 (109.34ms, 10.4MB)
# 테스트 18 〉	통과 (129.74ms, 10.2MB)
# 테스트 19 〉	통과 (23.31ms, 10.3MB)
# 테스트 20 〉	통과 (28.76ms, 10.4MB)
# 테스트 21 〉	통과 (29.33ms, 10.3MB)
# 테스트 22 〉	통과 (30.17ms, 10.4MB)
# 테스트 23 〉	통과 (38.96ms, 10.5MB)
# 테스트 24 〉	통과 (42.75ms, 10.3MB)
# 테스트 25 〉	통과 (30.78ms, 10.4MB)
# 테스트 26 〉	통과 (0.04ms, 10.1MB)